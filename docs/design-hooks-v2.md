# Unified Hooks System v2

## Overview

Unify the hooks and CI systems into a single model where:
- **Hook scripts** (`.lq/hooks/*.sh`) are the core primitive
- Scripts can run **with or without blq** (`--via=blq|standalone|auto`)
- Scripts can output **metadata hints** for CI log parsing
- Multiple **installation targets** (git, GitHub Actions, GitLab, etc.)

## Goals

1. **Portable execution**: Hook scripts work anywhere (CI, local, with/without blq)
2. **Consistent interface**: Same script, same args, regardless of context
3. **Traceable runs**: Metadata hints allow mapping CI runs back to blq commands
4. **Minimal dependencies**: Standalone mode needs only the underlying tool
5. **Explicit control**: Commands must be explicitly named for generation/installation

## Non-Goals

- Full CI orchestration (leave that to GitHub Actions, etc.)
- Complex workflow dependencies
- Automatic regeneration (explicit `generate` or `install` required)

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        blq config                               │
│  [commands.test]                                                │
│  tpl = "pytest {path} -v"                                       │
│  defaults = { path = "tests/" }                                 │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                   blq hooks generate                            │
│  Generates .lq/hooks/*.sh from registered commands              │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                    .lq/hooks/test.sh                            │
│  Portable shell script with embedded command info               │
└──────────────────────────┬──────────────────────────────────────┘
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
   │ git hooks   │  │ GitHub CI   │  │ manual      │
   │ pre-commit  │  │ workflow    │  │ invocation  │
   └─────────────┘  └─────────────┘  └─────────────┘
```

## Hook Script Specification

### Location and Naming

```
.lq/
├── hooks/
│   ├── lint.sh
│   ├── test.sh
│   └── format-check.sh
└── ...
```

Scripts are executable shell scripts. The `.lq/hooks/` directory should be added to `.gitignore` exception (tracked in git).

### Script Interface

```bash
.lq/hooks/test.sh [OPTIONS] [PARAMS...]

Options:
  --via=MODE          Execution mode: blq, standalone, auto (default: auto)
  --metadata=FORMAT   Output metadata: auto, none, json, header, footer, FILE (default: auto)
  --dry-run           Print command without executing

Params:
  key=value           Parameters for template substitution

Environment:
  BLQ_VIA             Default for --via (overridden by flag)
  BLQ_METADATA        Default for --metadata (overridden by flag)
```

### Metadata Modes

| Mode | Description |
|------|-------------|
| `auto` | Smart default: `none` when via=blq, `footer` when via=standalone |
| `none` | No metadata output |
| `json` | Print JSON blob to stdout before execution |
| `header` | Print `# blq:meta {...}` comment before execution |
| `footer` | Print `# blq:meta {...}` comment after execution (includes exit_code) |
| `FILE` | Write JSON to specified file |

**Metadata is a hint**: Not all fields will be available in all contexts. External systems (GitHub Actions, GitLab CI) may provide additional context (run IDs, job names) that gets merged during import.

### Example Script Structure

```bash
#!/bin/sh
# .lq/hooks/test.sh
# Generated by blq v0.7.0 - regenerate with: blq hooks generate test
# Checksum: a1b2c3d4e5f6 (from command definition)
#
# Command: test
# Template: pytest {path} -v --tb=short
# Defaults: path=tests/
# Generated: 2024-01-15T10:30:00Z

set -e

# === Embedded Command Info ===
BLQ_COMMAND="test"
BLQ_TEMPLATE="pytest {path} -v --tb=short"
BLQ_DEFAULTS_path="tests/"
BLQ_SCRIPT_VERSION="1"
BLQ_CHECKSUM="a1b2c3d4e5f6"

# === Parse Arguments ===
VIA="${BLQ_VIA:-auto}"
METADATA="${BLQ_METADATA:-auto}"
DRY_RUN=0
PARAMS=""

while [ $# -gt 0 ]; do
    case "$1" in
        --via=*) VIA="${1#--via=}" ;;
        --metadata=*) METADATA="${1#--metadata=}" ;;
        --dry-run) DRY_RUN=1 ;;
        *=*) PARAMS="$PARAMS $1" ;;
        *) echo "Unknown argument: $1" >&2; exit 1 ;;
    esac
    shift
done

# === Resolve Execution Mode ===
if [ "$VIA" = "auto" ]; then
    if command -v blq >/dev/null 2>&1; then
        VIA="blq"
    else
        VIA="standalone"
    fi
fi

# === Resolve Metadata Mode ===
# auto: none when via=blq (blq captures everything), footer when standalone
if [ "$METADATA" = "auto" ]; then
    if [ "$VIA" = "blq" ]; then
        METADATA="none"
    else
        METADATA="footer"
    fi
fi

# === Resolve Parameters ===
# Apply defaults, then override with provided params
path="${BLQ_DEFAULTS_path}"
for param in $PARAMS; do
    key="${param%%=*}"
    value="${param#*=}"
    eval "${key}=\"${value}\""
done

# === Build Commands ===
# Render template with resolved parameters
STANDALONE_CMD="pytest ${path} -v --tb=short"
BLQ_CMD="blq run test path=${path}"

# === Select Command ===
if [ "$VIA" = "blq" ]; then
    CMD="$BLQ_CMD"
else
    CMD="$STANDALONE_CMD"
fi

# === Dry Run ===
if [ "$DRY_RUN" = "1" ]; then
    echo "$CMD"
    exit 0
fi

# === Metadata Helpers ===
build_metadata() {
    # Build JSON with available fields (some may be empty)
    cat <<META_EOF
{"command":"$BLQ_COMMAND","via":"$VIA","params":{"path":"$path"},"exit_code":${1:-null},"git_sha":"$(git rev-parse HEAD 2>/dev/null || echo '')","timestamp":"$(date -u +%Y-%m-%dT%H:%M:%SZ)"}
META_EOF
}

emit_metadata_pre() {
    case "$METADATA" in
        none) ;;
        json) build_metadata ;;
        header) echo "# blq:meta $(build_metadata)" ;;
        footer) ;; # after execution
        *) build_metadata > "$METADATA" ;;  # write to file
    esac
}

emit_metadata_post() {
    case "$METADATA" in
        footer) echo "# blq:meta $(build_metadata $1)" ;;
        *) ;;  # already handled or none
    esac
}

# === Execute ===
emit_metadata_pre

set +e
eval "$CMD"
EXIT_CODE=$?
set -e

emit_metadata_post $EXIT_CODE
exit $EXIT_CODE
```

## Commands

### `blq hooks generate <commands...>`

Generate hook scripts from registered commands. **Commands must be explicitly named.**

```bash
blq hooks generate lint test        # Generate scripts for lint and test
blq hooks generate lint --force     # Overwrite existing script
```

Generates `.lq/hooks/lint.sh` and `.lq/hooks/test.sh`.

### `blq hooks install <target> <commands...>`

Install hooks to a target. **Commands must be explicitly named.** Automatically generates scripts if missing.

```bash
blq hooks install git lint format-check          # Install to .git/hooks/pre-commit
blq hooks install git lint --hook=pre-push       # Different git hook
blq hooks install github lint test               # Generate .github/workflows/blq-checks.yml
blq hooks install gitlab lint test               # Generate .gitlab-ci.yml fragment
```

### `blq hooks uninstall <target>`

Remove installed hooks.

```bash
blq hooks uninstall git                  # Remove .git/hooks/pre-commit
blq hooks uninstall git --hook=pre-push  # Remove specific hook
blq hooks uninstall github               # Remove generated workflow file
```

### `blq hooks run [commands...]`

Run hook scripts directly.

```bash
blq hooks run lint format-check     # Run specific hooks
blq hooks run                       # Run all generated hooks in .lq/hooks/
```

### `blq hooks status`

Show hook configuration and installation status.

```bash
blq hooks status
# Output:
# Hook Scripts (.lq/hooks/):
#   lint.sh         [ok]      ruff check . (checksum: a1b2c3)
#   test.sh         [ok]      pytest {path} -v (checksum: d4e5f6)
#   format-check.sh [missing] (not generated)
#
# Installations:
#   git pre-commit  [installed] lint.sh, format-check.sh
#   git pre-push    [not installed]
#   github actions  [not installed]
#
# Stale Scripts (command changed since generation):
#   (none)
```

## Configuration

### commands.toml

Commands remain unchanged - they define what can be run.

```toml
[commands.lint]
cmd = "ruff check ."

[commands.test]
tpl = "pytest {path} -v --tb=short"
defaults = { path = "tests/" }

[commands.format-check]
cmd = "ruff format --check ."
```

### config.toml (optional hooks section)

Minimal hook configuration - most behavior is explicit via CLI.

```toml
[hooks]
# Default --via mode for generated scripts (default: auto)
default_via = "auto"

# Default --metadata mode for generated scripts (default: auto)
default_metadata = "auto"
```

### .gitignore handling

Update `blq init` to add:

```gitignore
# blq
.lq/*
!.lq/hooks/
!.lq/config.toml
!.lq/commands.toml
```

This tracks hook scripts and config in git, but ignores database/logs.

## Installation Targets

### Git Hooks

```bash
blq hooks install git
blq hooks install git --hook=pre-push
blq hooks install git --suite=pre-commit  # Use named suite
```

Generates `.git/hooks/pre-commit`:

```bash
#!/bin/sh
# blq-managed-hook
# Suite: pre-commit
# To remove: blq hooks uninstall git

.lq/hooks/lint.sh && .lq/hooks/format-check.sh
```

### GitHub Actions

```bash
blq hooks install github
blq hooks install github --suite=ci
```

Generates `.github/workflows/blq-checks.yml`:

```yaml
# Generated by blq - edits may be overwritten
# Run: blq hooks install github --force
name: blq checks

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run lint
        run: .lq/hooks/lint.sh --via=standalone --metadata=footer

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install dependencies
        run: pip install -e ".[dev]"
      - name: Run tests
        run: .lq/hooks/test.sh --via=standalone --metadata=footer
```

### GitLab CI

```bash
blq hooks install gitlab
```

Generates `.gitlab-ci.blq.yml` (to be included):

```yaml
# Generated by blq
# Include in .gitlab-ci.yml: include: '.gitlab-ci.blq.yml'

lint:
  script:
    - .lq/hooks/lint.sh --via=standalone --metadata=footer

test:
  script:
    - .lq/hooks/test.sh --via=standalone --metadata=footer
```

## CI Import (Future Work)

**Deferred**: CI log import will be added to `blq ci` command in a future release. The metadata footer system is designed to support this.

Planned functionality:
```bash
blq ci import                           # Auto-detect from environment
blq ci import --from=github             # Import from GitHub Actions
blq ci import --from=gitlab             # Import from GitLab CI
blq ci import --log=build.log           # Import from log file
```

The import process will:
1. Parse log for `# blq:meta {...}` markers (metadata hints)
2. Extract command, params, exit code, git info from markers
3. Merge with CI-specific context (GitHub run ID, job name, etc.)
4. Optionally re-parse the log output for events (errors, warnings)
5. Create run record in blq storage

**Metadata is a hint**: The `# blq:meta` footer provides what's known at script execution time. The import process will enrich this with CI provider context.

## Migration Path

### Phase 1: Script Generation ✅
- Implement `blq hooks generate`
- Generate `.lq/hooks/*.sh` scripts using Jinja2 templates
- Update `.gitignore` handling

### Phase 2: Git Integration ✅
- Update `blq hooks install git` to use new scripts
- Deprecate direct hook template (PRECOMMIT_HOOK_TEMPLATE)
- Maintain backward compatibility

### Phase 3: CI Workflow Generation ✅
- Implement GitHub Actions generator (`blq hooks install github`)
- Implement GitLab CI generator (`blq hooks install gitlab`)
- Implement Drone CI generator (`blq hooks install drone`)
- Keep existing `blq ci` commands (check, comment) unchanged

### Phase 4: Polish ✅
- Add `blq hooks status` enhancements (shows CI workflow status, stale scripts)
- Documentation (SKILL.md updated)
- (Future) `blq ci import` for importing external CI logs

## File Changes

### New Files
- `src/blq/commands/hooks_gen.py` - Script generation logic
- `src/blq/commands/hooks_install.py` - Installation targets
- `src/blq/templates/` - Jinja2 templates directory
  - `hook_script.sh.j2` - Shell script template
  - `git_hook.sh.j2` - Git hook wrapper template
  - `github_workflow.yml.j2` - GitHub Actions template
  - `gitlab_ci.yml.j2` - GitLab CI template

### Modified Files
- `src/blq/commands/hooks_cmd.py` - Refactor to use new system
- `src/blq/cli.py` - Add new subcommands
- `src/blq/commands/core.py` - Config schema updates (parameter types)

### Unchanged
- `src/blq/commands/ci.py` - Keep existing check/comment commands

## Design Decisions

1. **Explicit generation**: No auto-regeneration. `blq hooks generate` and `blq hooks install` require explicit command names.

2. **Checksum/versioning**: Scripts include checksum of command definition. `blq hooks status` shows stale scripts. **Stale scripts warn but still run.**

3. **No hooks.toml**: Configuration is minimal, lives in `[hooks]` section of `config.toml`.

4. **Metadata=auto**: Smart default - `none` when via=blq, `footer` when via=standalone.

5. **Simple CI generation**: Generated workflows are intentionally simple. This is plumbing for standardization, not a full CI system.

6. **Jinja2 templates**: Use Jinja2 for script generation to support multiple shell types in the future (sh, bash, powershell).

7. **Parameter types**: Commands can define parameter types to guide escaping. This ensures safe handling of special characters.

## Parameter Types (Future Enhancement)

Commands may specify parameter types to guide escaping:

```toml
[commands.test]
tpl = "pytest {path} -k {filter}"
defaults = { path = "tests/" }

[commands.test.params]
path = { type = "path" }      # Path escaping
filter = { type = "string" }  # Shell string escaping
```

For now, all parameters are treated as strings with basic shell escaping.

## Open Questions

1. **Template engine**: Jinja2 is the obvious choice (already common in Python). Confirm this is acceptable.

2. **Jinja2 dependency**: Add to core deps or optional? (Recommend: core, it's lightweight)
